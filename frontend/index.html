<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Travel Guardian 360 — Demo</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body, #map {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255,255,255,0.95);
            padding: 8px;
            border-radius: 6px;
            font-family: sans-serif;
            font-size: 13px;
            width: 320px;
        }

        .btn {
            margin: 6px 0;
            width: 100%;
        }

        #status {
            font-size: 12px;
            margin-top: 6px;
            color: #333;
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            font-family: sans-serif;
            font-size: 14px;
            z-index: 1000;
        }

        #event-log {
            position: fixed;
            bottom: 64px;
            right: 10px;
            width: 300px;
            max-height: 260px;
            overflow-y: auto;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            font-family: monospace;
            font-size: 12px;
            padding: 6px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label>Src: <input id="src" type="number" value="0" min="0" max="9" /></label>
            <label style="margin-left:8px">Dst: <input id="dst" type="number" value="5" min="0" max="9" /></label>
            <button id="routeBtn" class="btn">Compute Route</button>
            <button id="monitorBtn" class="btn">Monitor this route (threshold: <input id="monitorThreshold" type="number" value="3" min="1" style="width:60px"> min)</button>

            <hr />
            <div>
                <label for="icsFile">Upload .ics calendar:</label>
                <input type="file" id="icsFile" accept=".ics" />
                <button id="uploadIcsBtn" class="btn">Upload Calendar</button>
                <div id="calendarStatus" style="font-size:12px;margin-top:6px"></div>
            </div>

        </div>
        <div style="margin-top:8px">
            <strong>Persona</strong><br />
            <input id="personaName" placeholder="Name" style="width:100px" />
            <button id="personaPredictBtn">Predict for Persona</button>

            <!-- NEW: Persona quick selector + use button -->
            <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
                <select id="personaList" style="flex:1; min-width:120px;">
                    <option value="">(choose)</option>
                </select>
                <button id="usePersonaBtn" class="btn" style="width:auto; padding:6px 10px;">Use Persona</button>
            </div>

            <div id="dnaPanel" style="margin-top:6px;font-size:13px"></div>
        </div>
        <hr />
        <div>
            <label>Report Node: <input id="rnode" type="number" value="1" min="0" max="5" style="width:70px" /></label>
            <input id="rdesc" placeholder="description" style="width:100%;margin-top:6px" />
            <div style="display:flex;gap:8px;margin-top:6px">
                <select id="rseverity" style="flex:1">
                    <option value="1">Minor</option>
                    <option value="2" selected>Moderate</option>
                    <option value="3">Major</option>
                </select>
                <input id="rduration" type="number" value="120" min="5" max="3600" style="width:100px" />
            </div>
            <div style="display:flex;gap:8px;margin-top:6px">
                <button id="reportBtn" class="btn" style="flex:1">Report Incident</button>
                <button id="simulateBtn" class="btn" style="flex:1">Simulate (async)</button>
            </div>
        </div>
        <hr />
        <div>
            <button id="refreshBtn" class="btn">Refresh Incidents</button>
        </div>
        <div id="status">Status: idle</div>
    </div>

    <div id="map"></div> <!--map is here-->
    <!--//status bar div-->
    <div id="status-bar" style="
  position: fixed; bottom: 0; left: 0; right: 0;
  background: rgba(0,0,0,0.9); color: #fff; padding: 8px 12px;
  font-family: sans-serif; font-size:14px; z-index:1000; display:flex;
  gap:12px; align-items:center; justify-content:space-between;
">
        <!-- Left side -->
        <span id="status-message">Status: Ready</span>

        <!-- Right side -->
        <div>
            ETA:
            <span id="eta-baseline">-</span> →
            <span id="eta-current">-</span> (DNA:
            <span id="eta-dna">-</span>)
        </div>
    </div>
        

    <!--ETA display temp fix-->
    <div id="etaDisplay" style="
  position:absolute; top:10px; right:10px;
  background:white; padding:6px 10px; border-radius:6px;
  box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-family:sans-serif; font-size:14px; z-index:1000;
">
        ETA will appear here
    </div>

    <div id="event-log"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>

        // --- UI Helper ---
        function safeSetText(id, text) {
            const el = document.getElementById(id);
            if (el) {
                el.innerText = text;
            } else {
                console.warn("safeSetText: missing element #" + id);
            }
        }

        /* =========================
           Configuration
           ========================= */
        const API = "http://localhost:8080";

        /* Debounce / UX tuning */
        const ROUTE_DEBOUNCE_MS = 600;     // how long to coalesce route recomputes
        const SSE_RECONNECT_MS = 4000;     // if SSE dies, try reconnect after this ms

        /* Keep state */
        let currentSrc = null, currentDst = null;
        let _lastRouteCompute = 0;
        let _routeComputeTimeout = null;
        let _fitBoundsDone = false;

        /* Map & nodes
           - set map center and node coordinates together so nodes lie on visible roads.
           - change these coordinates to whatever city/area you want.
        */
        const map = L.map('map').setView([50.0642, 19.9895], 14);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '' }).addTo(map);

        // Default 6 node coordinates here for demo but for future we can OSRM or mapbox maybe 
        const nodes = [
            [50.0741, 20.0042],
            [50.0706, 20.0048],
            [50.0673, 20.0046],
            [50.0644, 19.9894],
            [50.0676, 19.9888],
            [50.0676, 19.9903],
            [50.0732, 19.9860],
            [50.0714, 19.9835],
            [50.0697, 19.9866],
            [50.0685, 19.9884]
        ];

        /* draw static node markers & edges for context */
        const nodeMarkers = [];
        for (let i = 0; i < nodes.length; i++) {
            const m = L.circleMarker(nodes[i], { radius: 7, color: '#222', fillColor: '#fff', fillOpacity: 1 }).addTo(map).bindPopup("Node " + i);
            nodeMarkers.push(m);
        }
        // --- explicit edge list that matches server build_demo_graph() ---
        // Perimeter edges (only these get the grey background)
        // and two interior connectors (comment out if you DO NOT want them)
        const edges = [
            [0, 6], [0, 1], [1, 2], [2, 3], [3, 4], [4, 5],[6, 7], [7, 8],[8,9],[9,4]
            // optional connectors: include only if you WANT these shown
            // [1,5], [7,3]
        ];

        // Keep references if you want to remove them later
        const backgroundEdgeLayers = [];

        backgroundEdgeLayers.forEach(l => { try { map.removeLayer(l); } catch (e) { } });
        backgroundEdgeLayers.length = 0;

        // Draw edges: perimeter solid grey, connectors dashed (or comment connectors out)
        edges.forEach(e => {
            const a = nodes[e[0]];
            const b = nodes[e[1]];
            if (!a || !b) return;

            const isConnector =
                (e[0] === 1 && e[1] === 5) || (e[0] === 5 && e[1] === 1) ||
                (e[0] === 7 && e[1] === 3) || (e[0] === 3 && e[1] === 7);

            const opts = isConnector
                ? { color: '#cc8800', dashArray: '6,6', weight: 2, opacity: 0.6 } // connector style
                : { color: '#888', weight: 2, opacity: 0.6 };                     // perimeter style

            const pl = L.polyline([a, b], opts).addTo(map);
            backgroundEdgeLayers.push(pl);
        });


        /* =========================
           UI helpers
           ========================= */
        function setStatus(text) {
            // Only update the dedicated span inside the status bar
            safeSetText('status-message', "Status: " + text);
        }


        /* Route drawing: keep references to lines and update in-place for smoothness */
        window.currentPathLines = window.currentPathLines || { baselineLine: null, adjustedLine: null };

        /* =========================
           Incident marker management (incremental)
           ========================= */
        window.incidentMap = window.incidentMap || new Map();
        let _lastIncidentsSerialized = "";

        function createSeverityMarker(latlng, severity) {
            const color = (severity >= 3) ? '#b30000' : (severity === 2 ? '#ff8c00' : '#ffd700');
            return L.circleMarker(latlng, { radius: 9, fillColor: color, color: '#222', weight: 1, fillOpacity: 0.95 });
        }

        const logDiv = document.getElementById("event-log");
        function pushLogLine(text, severity = 1) {
            if (!logDiv) return;
            const p = document.createElement('div');
            p.textContent = text;
            if (severity >= 3) { p.style.color = "darkred"; p.style.fontWeight = "700"; }
            else if (severity === 2) { p.style.color = "darkorange"; }
            else { p.style.color = "#333"; }
            logDiv.insertBefore(p, logDiv.firstChild);
            while (logDiv.childNodes.length > 40) logDiv.removeChild(logDiv.lastChild);
        }

        function formatIncident(inc) {
            let sevLabel = "Unknown";
            let sevIcon = "❓";
            let msg = "";

            switch (inc.severity) {
                case 1:
                    sevLabel = "Minor";
                    sevIcon = "⚠️";
                    msg = `Minor delay at Stop ${inc.node_or_edge} (expect ~2 min longer)`;
                    break;
                case 2:
                    sevLabel = "Moderate";
                    sevIcon = "🚧";
                    msg = `Moderate disruption at Stop ${inc.node_or_edge} (expect ~5–10 min longer)`;
                    break;
                case 3:
                    sevLabel = "Major";
                    sevIcon = "🚨";
                    msg = `Major disruption at Stop ${inc.node_or_edge} — severe delays likely`;
                    break;
                default:
                    msg = `Incident at Stop ${inc.node_or_edge}`;
            }

            return {
                label: sevLabel,
                icon: sevIcon,
                message: msg,
                raw: inc
            };
        }

        function renderIncidentsIncremental(list) {
            const incoming = new Map();
            (list || []).forEach(i => incoming.set(String(i.id), i));

            // remove cleared
            for (const [id, entry] of window.incidentMap.entries()) {
                if (!incoming.has(id)) {
                    try { map.removeLayer(entry.marker); } catch (e) { }
                    window.incidentMap.delete(id);
                    pushLogLine(`[${new Date().toLocaleTimeString()}] Cleared id=${id}`, 1);
                }
            }

            // add/update incoming
            incoming.forEach((inc, id) => {
                const prev = window.incidentMap.get(id);
                const severity = inc.severity || 1;
                const latlng = nodes[inc.node_or_edge];
                if (!latlng) return; // invalid node

                const fmt = formatIncident(inc); // friendly text

                if (!prev) {
                    const m = createSeverityMarker(latlng, severity).addTo(map);
                    m.bindPopup(`<div style="font-size:13px"><strong>${fmt.message}</strong><br/><em>${inc.description || ''}</em><br/>id: ${inc.id}</div>`);
                    window.incidentMap.set(id, { marker: m, inc: JSON.stringify(inc) });
                    pushLogLine(`[${new Date().toLocaleTimeString()}] New: ${fmt.message} (id:${id})`, severity);
                } else {
                    const serialized = JSON.stringify(inc);
                    if (serialized !== prev.inc) {
                        // update style/popup
                        try {
                            prev.marker.setStyle && prev.marker.setStyle({ fillColor: (severity >= 3) ? '#b30000' : (severity === 2 ? '#ff8c00' : '#ffd700') });
                            prev.marker.setPopupContent && prev.marker.setPopupContent(`<div style="font-size:13px"><strong>${fmt.message}</strong><br/><em>${inc.description || ''}</em><br/>id: ${inc.id}</div>`);
                        } catch (e) { /* ignore popup update errors */ }
                        prev.inc = serialized;
                        pushLogLine(`[${new Date().toLocaleTimeString()}] Updated: ${fmt.message} (id:${id})`, severity);
                    }
                }
            });

            setStatus("Incidents: " + (list ? list.length : 0));
        }


        /* =========================
           Fetch incidents (fallback)
           ========================= */
        async function fetchIncidents() {
            try {
                const res = await fetch(API + '/incidents');
                const arr = await res.json();
                renderIncidentsIncremental(arr);
            } catch (e) {
                setStatus("incidents fetch failed: " + e.message);
            }
        }

        /* =========================
           Route computation (debounced, smooth draw)
           ========================= */
        async function computeRoute(src, dst) {
            const now = Date.now();
            if (now - _lastRouteCompute < ROUTE_DEBOUNCE_MS) {
                if (_routeComputeTimeout) clearTimeout(_routeComputeTimeout);
                _routeComputeTimeout = setTimeout(() => { _routeComputeTimeout = null; computeRoute(src, dst); }, ROUTE_DEBOUNCE_MS);
                return;
            }
            _lastRouteCompute = now;
            currentSrc = src; currentDst = dst;
            setStatus("computing route...");

            try {
                const r = await fetch(API + '/route', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ src, dst }) });
                const j = await r.json();
                console.log("route response", j);

                // prepare pts
                let baselinePts = null, adjustedPts = null;
                if (j.baseline && Array.isArray(j.baseline.path) && j.baseline.path.length) baselinePts = j.baseline.path.map(i => nodes[i]);
                if (j.adjusted && Array.isArray(j.adjusted.path) && j.adjusted.path.length) adjustedPts = j.adjusted.path.map(i => nodes[i]);

                // baseline (dashed blue)
                if (baselinePts) {
                    if (window.currentPathLines.baselineLine) {
                        window.currentPathLines.baselineLine.setLatLngs(baselinePts);
                    } else {
                        window.currentPathLines.baselineLine = L.polyline(baselinePts, { dashArray: '6,6', weight: 3, color: '#0077cc' }).addTo(map);
                    }
                } else {
                    if (window.currentPathLines.baselineLine) { map.removeLayer(window.currentPathLines.baselineLine); window.currentPathLines.baselineLine = null; }
                }

                // adjusted (solid red)
                if (adjustedPts) {
                    if (window.currentPathLines.adjustedLine) {
                        window.currentPathLines.adjustedLine.setLatLngs(adjustedPts);
                    } else {
                        window.currentPathLines.adjustedLine = L.polyline(adjustedPts, { color: 'red', weight: 4 }).addTo(map);
                    }
                } else {
                    if (window.currentPathLines.adjustedLine) { map.removeLayer(window.currentPathLines.adjustedLine); window.currentPathLines.adjustedLine = null; }
                }

                // compute ETAs and saved text
                const baseEta = (j.baseline && typeof j.baseline.eta_minutes === 'number') ? j.baseline.eta_minutes : null;
                const adjEta = (j.adjusted && typeof j.adjusted.eta_minutes === 'number') ? j.adjusted.eta_minutes : null;
                let recText = '';
                if (j.recommendation === 'baseline_faster') recText = 'Baseline route is faster';
                else if (j.recommendation === 'adjusted_faster') recText = 'Alternative is faster';
                else if (j.recommendation === 'equal') recText = 'Both equal';
                else if (j.recommendation === 'no_path') recText = 'No path available';

                let savedText = '';
                if (baseEta !== null && adjEta !== null) {
                    const diff = baseEta - adjEta;
                    if (diff > 0) savedText = ` ✅ Baseline faster by ${Math.abs(diff)} min`;
                    else if (diff < 0) savedText = ` 🚀 Adjusted faster by ${Math.abs(diff)} min`;
                    else savedText = ` ⚖ Equal time`;
                } else if (baseEta !== null && adjEta === null) savedText = ` ⚠ Only baseline available`;
                else if (adjEta !== null && baseEta === null) savedText = ` ⚠ Only adjusted available`;

                // --- SAFE ETA DOM UPDATES ---
                try {
                    const baseText = baseEta !== null ? `${baseEta} min` : 'n/a';
                    const adjText = adjEta !== null ? `${adjEta} min` : 'n/a';
                    const recTextSafe = recText || '—';
                    const savedTextSafe = savedText || '';

                    // status bar fields
                    safeSetText('eta-baseline', baseText);
                    safeSetText('eta-current', adjText);
                    safeSetText('eta-rec', recTextSafe);
                    safeSetText('eta-saved', savedTextSafe);

                    // --- update DNA ETA display (if present) ---
                    try {
                        const dnaVal = (j && typeof j.dna_predicted_extra_minutes === 'number') ? Math.round(j.dna_predicted_extra_minutes) : null;
                        if (dnaVal !== null) {
                            safeSetText('eta-dna', dnaVal + 'm');
                        } else {
                            // fallback: if server supplied string message only
                            if (j && j.dna_message) safeSetText('eta-dna', j.dna_message);
                            else safeSetText('eta-dna', '—');
                        }
                    } catch (e) {
                        console.warn('dna display update failed', e);
                        safeSetText('eta-dna', '—');
                    }

                    // show calendar conflict if present
                    // --- calendar conflict UI (non-destructive) ---
                    try {
                        if (j && j.calendar_conflict) {
                            const msg = j.calendar_conflict_msg || "Calendar conflict detected";
                            pushLogLine("[CALENDAR] " + msg, 2);

                            // show in the small calendar UI area if present
                            safeSetText('calendarStatus', msg);
                            const calEl = document.getElementById('calendarStatus');
                            if (calEl) calEl.style.color = "orange";

                            // non-destructive status update: append to existing status-message
                            const prev = (document.getElementById('status-message') && document.getElementById('status-message').innerText) || "Status:";
                            setStatus(prev + " | Calendar: " + msg);
                        } else {
                            // clear calendar UI if no conflict
                            safeSetText('calendarStatus', '');
                        }
                    } catch (e) {
                        console.warn("calendar display failed", e);
                    }


                    // status line
                    setStatus(`ETA (baseline): ${baseText} | ETA (current): ${adjText}`);

                    // top-right persistent ETA display
                    const etaDisplay = document.getElementById('etaDisplay');
                    if (etaDisplay) {
                        etaDisplay.innerText =
                            `Baseline: ${baseText} | Adjusted: ${adjText} | ${recTextSafe} ${savedTextSafe}`;
                    }
                } catch (domErr) {
                    console.error("ETA DOM update failed:", domErr);
                }

                // fit bounds only once to avoid jumping
                try {
                    if (!_fitBoundsDone) {
                        const allPts = [];
                        if (baselinePts) allPts.push(...baselinePts);
                        if (adjustedPts) allPts.push(...adjustedPts);
                        if (allPts.length) {
                            const bounds = L.latLngBounds(allPts);
                            map.fitBounds(bounds.pad(0.2), { animate: true });
                            _fitBoundsDone = true;
                        }
                    }
                } catch (e) { /* ignore */ }

            } catch (e) {
                setStatus("route error: " + e.message);
            }
        }

        /* =========================
           UI bindings
           ========================= */
        document.getElementById('routeBtn').addEventListener('click', () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            computeRoute(src, dst);
        });

        document.getElementById('simulateBtn').addEventListener('click', async () => {
            const node = Number(document.getElementById('rnode').value);
            const desc = document.getElementById('rdesc').value || "simulated";
            const severity = Number(document.getElementById('rseverity').value || 2);
            const duration_s = Number(document.getElementById('rduration').value || 120);
            try {
                const r = await fetch(API + '/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node, desc, delay_ms: 200, severity, duration_s })
                });
                const j = await r.json();
                console.log("simulate response", j);
                setStatus("simulate scheduled (server accepted)");
            } catch (e) { setStatus("simulate failed: " + e.message); console.error(e); }
        });
        document.getElementById('reportBtn').addEventListener('click', async () => {
            const node = Number(document.getElementById('rnode').value);
            const desc = document.getElementById('rdesc').value || "reported";
            const severity = Number(document.getElementById('rseverity').value || 2);
            const duration_s = Number(document.getElementById('rduration').value || 120);
            try {
                const r = await fetch(API + '/report', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node, desc, severity, duration_s })
                });
                const j = await r.json();
                console.log("report response", j);
                setStatus("report submitted");
            } catch (e) { setStatus("report failed: " + e.message); console.error(e); }
        });

        document.getElementById('refreshBtn').addEventListener('click', fetchIncidents);

        // Safe persona predict handler (replace your existing handler with this)
        document.getElementById('personaPredictBtn').addEventListener('click', async () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            const personaName = (document.getElementById('personaName') && document.getElementById('personaName').value) || 'Persona';
            const persona = { name: personaName };

            try {
                const resp = await fetch(API + '/predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ src, dst, persona })
                });

                if (!resp.ok) {
                    const text = await resp.text().catch(() => '');
                    pushLogLine(`predict failed: HTTP ${resp.status} ${text}`, 2);
                    return;
                }

                const j = await resp.json();
                // defensive extracts
                const predicted = (typeof j.dna_predicted_extra_minutes === 'number') ? j.dna_predicted_extra_minutes : Number(j.dna_predicted_extra_minutes) || 0;
                pushLogLine(`Persona "${personaName}" predicted extra: ${predicted} min`, 1);

                // show dna message
                const panel = document.getElementById('dnaPanel');
                if (panel) {
                    const el = document.createElement('div');
                    el.style.marginTop = '6px';
                    el.textContent = `${personaName}: +${predicted} min — ${j.dna_message || ''}`;
                    panel.appendChild(el);
                }

                // Visual persona alert: if server flagged dna_alert, show big notice
                try {
                    if (j.dna_alert) {
                        const alertMsg = (j.dna_alert_msg && j.dna_alert_msg.detail) ? j.dna_alert_msg.detail : `Predicted delay ~${predicted} min`;
                        pushLogLine(`⚠️ PERSONA ALERT: ${personaName} — ${alertMsg}`, 3);

                        // flash the status bar briefly
                        const statusBar = document.getElementById('status-bar');
                        if (statusBar) {
                            const origBg = statusBar.style.background;
                            statusBar.style.transition = "background 0.3s";
                            statusBar.style.background = "#8a2b2b"; // alert red tone
                            setTimeout(() => { statusBar.style.background = origBg; }, 2500);
                        }

                        // show suggested alternative (if provided)
                        if (j.suggested_route) {
                            const s = j.suggested_route;
                            const altText = (s.which && s.which !== 'none') ? `Suggested: ${s.which} (ETA ${s.eta_minutes}m, saves ${s.saved_minutes}m)` : 'No alternative available';
                            pushLogLine(`SUGGESTION: ${altText}`, 1);

                            // Optionally, update the ETA display for the suggestion quickly
                            safeSetText('eta-dna', `+${Math.round(predicted)}m`);
                            // highlight adjusted/baseline line depending on suggestion
                            if (s.which === 'adjusted' && window.currentPathLines && window.currentPathLines.adjustedLine) {
                                window.currentPathLines.adjustedLine.setStyle({ color: '#ff4d4d', weight: 8 });
                                setTimeout(() => { if (window.currentPathLines.adjustedLine) window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 }); }, 3500);
                            } else if (s.which === 'baseline' && window.currentPathLines && window.currentPathLines.baselineLine) {
                                window.currentPathLines.baselineLine.setStyle({ color: '#2ecc40', weight: 8 });
                                setTimeout(() => { if (window.currentPathLines.baselineLine) window.currentPathLines.baselineLine.setStyle({ dashArray: '6,6', weight: 3, color: '#0077cc' }); }, 3500);
                            }
                        }
                    }
                } catch (e) {
                    console.error('persona alert UI failed', e);
                }
            } catch (err) {
                    console.error('predict handler failed', err);
                    pushLogLine(`predict error: ${err && err.message ? err.message : String(err)}`, 2);
                }
            });

        document.getElementById('uploadIcsBtn').addEventListener('click', async () => {
            const fileInput = document.getElementById('icsFile');
            const statusEl = document.getElementById('calendarStatus');
            if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                if (statusEl) statusEl.innerText = "Select an .ics file first.";
                return;
            }
            const f = fileInput.files[0];
            const text = await f.text().catch(e => { if (statusEl) statusEl.innerText = "Failed reading file."; return null; });
            if (!text) return;

            try {
                const resp = await fetch(API + '/calendar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: text
                });
                const j = await resp.json();
                if (j.imported !== undefined) {
                    if (statusEl) statusEl.innerText = `Imported ${j.imported} events`;
                } else {
                    if (statusEl) statusEl.innerText = `Import response: ${JSON.stringify(j)}`;
                }
            } catch (e) {
                if (statusEl) statusEl.innerText = "Upload failed: " + e.message;
            }
        });


        // monitor button handler
        document.getElementById('monitorBtn').addEventListener('click', async () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            const threshold = Number(document.getElementById('monitorThreshold').value || 3);
            try {
                const r = await fetch(API + '/monitor', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ src, dst, threshold })
                });
                const j = await r.json();
                if (j.monitor_id) {
                    pushLogLine(`Monitoring route ${src}->${dst} (id:${j.monitor_id}) threshold:${threshold}min`, 1);
                } else {
                    pushLogLine(`Monitor failed: ${JSON.stringify(j)}`, 1);
                }
            } catch (e) {
                pushLogLine(`Monitor POST error: ${e.message}`, 1);
            }
        });

        // inside your SSE onmessage handler (where you parse data), add:
        //if (data.monitor_alerts && data.monitor_alerts.length) {
        //    data.monitor_alerts.forEach(a => {
        //        // friendly text
        //        const text = `[ALERT] route ${a.src}->${a.dst} delayed by ${a.delta} min (eta ${a.eta_adj} vs baseline ${a.eta_base})`;
        //        pushLogLine(text, 3);
        //        // visual: flash status or show toast
        //        setStatus("ALERT: " + text);
        //        // optionally show a big callout on map or highlight lines:
        //        if (window.currentPathLines && window.currentPathLines.adjustedLine) {
        //            // briefly pulse the adjusted line
        //            window.currentPathLines.adjustedLine.setStyle({ color: '#ff0000', weight: 6 });
        //            setTimeout(() => {
        //                if (window.currentPathLines.adjustedLine) window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 });
        //            }, 4000);
        //        }
        //    });
        //}

        /* =========================
           SSE subscribe (reconnect on error)
           ========================= */
        function subscribeEvents() {
            let evt = null;

            function connect() {
                evt = new EventSource(API + "/events");
                evt.onopen = () => { console.log("SSE connected"); pushLogLine(`[${new Date().toLocaleTimeString()}] SSE connected`, 1); };
                evt.onmessage = function (ev) {
                    try {
                        const data = JSON.parse(ev.data);

                        // === Existing incident handling ===
                        const list = data.incidents || [];
                        const serialized = JSON.stringify(list.map(i => ({
                            id: i.id,
                            node: i.node_or_edge,
                            sev: i.severity,
                            expires: i.expires_at
                        })));
                        if (serialized !== _lastIncidentsSerialized) {
                            _lastIncidentsSerialized = serialized;
                            renderIncidentsIncremental(list);
                        }

                        // === NEW: DNA summary panel ===
                        if (data.dna_summary) {
                            try {
                                const dna = data.dna_summary;
                                const stats = dna.node_stats || {};
                                let html = '<strong>TransitDNA</strong><br/>';
                                const keys = Object.keys(stats)
                                    .sort((a, b) => (stats[b].avg_delay || 0) - (stats[a].avg_delay || 0))
                                    .slice(0, 3);
                                keys.forEach(k => {
                                    const s = stats[k];
                                    html += `Node ${k}: ${Math.round((s.avg_delay || 0))}m (n=${s.count || 0})<br/>`;
                                });
                                const el = document.getElementById('dnaPanel');
                                if (el) el.innerHTML = html;
                            } catch (e) { console.error('dna render err', e); }
                        }

                        // === NEW: Monitor alerts ===
                        // === NEW: Monitor alerts ===
                        if (data.monitor_alerts && data.monitor_alerts.length) {
                            data.monitor_alerts.forEach(a => {
                                const text = `[ALERT] route ${a.src}->${a.dst} delayed by ${a.delta} min (eta ${a.eta_adj} vs baseline ${a.eta_base})`;
                                pushLogLine(text, 3);
                                setStatus("ALERT: " + text);
                                if (window.currentPathLines && window.currentPathLines.adjustedLine) {
                                    window.currentPathLines.adjustedLine.setStyle({ color: '#ff0000', weight: 6 });
                                    setTimeout(() => {
                                        if (window.currentPathLines.adjustedLine)
                                            window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 });
                                    }, 4000);
                                }
                            });
                        }

                        // === NEW: DNA alerts (server-side) ===
                        try {
                            if (data.dna_alerts && Array.isArray(data.dna_alerts) && data.dna_alerts.length) {
                                data.dna_alerts.forEach(a => {
                                    try {
                                        const msg = `[DNA ALERT] ${a.message || ''} (predicted +${Math.round(a.predicted_extra_minutes || 0)}m)`;
                                        pushLogLine(msg, 3);

                                        // flash the status bar
                                        const sb = document.getElementById('status-bar');
                                        if (sb) {
                                            const prevBg = sb.style.background;
                                            sb.style.transition = "background 0.2s";
                                            sb.style.background = '#8a2b2b';
                                            setTimeout(() => { sb.style.background = prevBg; }, 2500);
                                        }

                                        // optional: highlight adjusted line if suggestion exists
                                        if (a.suggested_route && a.suggested_route.which === 'adjusted' && window.currentPathLines && window.currentPathLines.adjustedLine) {
                                            window.currentPathLines.adjustedLine.setStyle({ color: '#ff4d4d', weight: 8 });
                                            setTimeout(() => { if (window.currentPathLines.adjustedLine) window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 }); }, 3500);
                                        }
                                    } catch (e) { console.warn('dna_alert render item failed', e, a); }
                                });
                            }
                        } catch (e) { console.warn('dna_alerts render failed', e); }

                    } catch (err) {
                        console.error("SSE parse error", err, ev.data);
                    }
                };

                evt.onerror = (err) => {
                    console.error("SSE error", err);
                    pushLogLine(`[${new Date().toLocaleTimeString()}] SSE connection error — reconnecting...`, 1);
                    try { evt.close(); } catch (e) { }
                    setTimeout(connect, SSE_RECONNECT_MS);
                };
            }

            connect();
        }

        // Quick hardcoded persona for demo (inserted just before subscribeEvents())
        const savedPersonas = {
            "Sarah": { name: "Sarah", preferred_src: 0, preferred_dst: 5, leave_minutes_before: 10 }
        };

        // add a quick button to use Sarah
        (function addSarahButton() {
            const c = document.getElementById('controls');
            if (!c) return;
            const btn = document.createElement('button');
            btn.innerText = 'Use Sarah';
            btn.className = 'btn';
            btn.style.marginTop = '6px';
            btn.addEventListener('click', () => {
                const persona = savedPersonas.Sarah;
                const pn = document.getElementById('personaName');
                const s = document.getElementById('src');
                const d = document.getElementById('dst');
                if (pn) pn.value = persona.name;
                if (s) s.value = persona.preferred_src;
                if (d) d.value = persona.preferred_dst;
                pushLogLine('Loaded persona Sarah', 1);
            });
            c.appendChild(btn);
        })();
        /* --- Persona list loader and Use Persona handler --- */
        async function loadPersonas() {
            try {
                console.log('[ui] loadPersonas: fetching /personas...');
                const resp = await fetch(API + '/personas');
                if (!resp.ok) {
                    console.warn('[ui] /personas returned', resp.status);
                    // fallback to local demo persona if server blocked
                    populatePersonasFromLocal();
                    return;
                }
                const arr = await resp.json();
                console.log('[ui] /personas =>', arr);
                const sel = document.getElementById('personaList');
                if (!sel) { console.warn('[ui] missing #personaList element'); return; }
                sel.innerHTML = '<option value="">(choose)</option>';
                if (!Array.isArray(arr) || arr.length === 0) {
                    // server has no saved personas — fall back to local demo
                    populatePersonasFromLocal();
                    return;
                }
                arr.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.name || JSON.stringify(p);
                    opt.text = p.name || (p.summary || opt.value);
                    sel.appendChild(opt);
                });
            } catch (e) {
                console.error('[ui] loadPersonas failed', e);
                // fallback to local demo if server unreachable
                populatePersonasFromLocal();
            }
        }

        // helper: fill dropdown from local savedPersonas if server empty
        function populatePersonasFromLocal() {
            const sel = document.getElementById('personaList');
            if (!sel) return;
            sel.innerHTML = '<option value="">(choose)</option>';
            for (const k of Object.keys(savedPersonas)) {
                const p = savedPersonas[k];
                const opt = document.createElement('option');
                opt.value = p.name;
                opt.text = p.name;
                sel.appendChild(opt);
            }
            console.log('[ui] populatePersonasFromLocal used');
        }

        document.getElementById('usePersonaBtn').addEventListener('click', async () => {
            const sel = document.getElementById('personaList');
            if (!sel) { pushLogLine('Persona selector missing', 2); return; }
            const name = sel.value;
            if (!name) { pushLogLine('Select a persona first', 1); return; }

            try {
                // Always fetch all and find the persona (server may not support per-name query)
                const resp = await fetch(API + '/personas');
                let all = [];
                if (resp.ok) {
                    all = await resp.json();
                } else {
                    console.warn('[ui] GET /personas returned', resp.status, ' — using local fallback');
                }
                let p = (Array.isArray(all) ? all.find(x => x.name === name) : null);
                if (!p) {
                    // fallback to local savedPersonas
                    p = savedPersonas[name] || null;
                }
                if (!p) { pushLogLine('Persona not found: ' + name, 2); return; }

                if (document.getElementById('personaName')) document.getElementById('personaName').value = p.name || name;
                if (typeof p.src !== 'undefined' && document.getElementById('src')) document.getElementById('src').value = p.src;
                if (typeof p.dst !== 'undefined' && document.getElementById('dst')) document.getElementById('dst').value = p.dst;
                // optional preferred fields
                if (typeof p.preferred_src !== 'undefined' && document.getElementById('src')) document.getElementById('src').value = p.preferred_src;
                if (typeof p.preferred_dst !== 'undefined' && document.getElementById('dst')) document.getElementById('dst').value = p.preferred_dst;

                pushLogLine(`Loaded persona ${p.name}`, 1);

                // autosave quick: populate persona on server if not present (non-blocking)
                if (!all || !all.find(x => x.name === p.name)) {
                    fetch(API + '/persona/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: p.name, src: p.preferred_src ?? p.src ?? 0, dst: p.preferred_dst ?? p.dst ?? 5 })
                    }).then(() => { console.log('[ui] persona auto-saved to server'); }).catch(() => { });
                }

                // immediately compute route for persona defaults
                const src = Number(document.getElementById('src').value);
                const dst = Number(document.getElementById('dst').value);
                computeRoute(src, dst);
            } catch (e) {
                console.error('usePersona failed', e);
                pushLogLine('usePersona failed', 2);
            }
        });

        // load personas once on page load added a safety check for the personas as well
        window.addEventListener('load', () => {
            loadPersonas();
            // also populate quick local Sarah button if you want
        });

        //--------------------WE CALL SUBCRIBE EVENTS HERE-------------------------
        subscribeEvents();

        /* initial fallback */
        fetchIncidents();
        setInterval(fetchIncidents, 30000); // very infrequent fallback polling ...forgot why i needed this honestly uhh...I am dumb
    </script>
</body>
</html>
