<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Travel Guardian 360 ‚Äî Demo</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body, #map {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255,255,255,0.95);
            padding: 8px;
            border-radius: 6px;
            font-family: sans-serif;
            font-size: 13px;
            width: 320px;
        }

        .btn {
            margin: 6px 0;
            width: 100%;
        }

        #status {
            font-size: 12px;
            margin-top: 6px;
            color: #333;
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            font-family: sans-serif;
            font-size: 14px;
            z-index: 1000;
        }

        #event-log {
            position: fixed;
            bottom: 64px;
            right: 10px;
            width: 300px;
            max-height: 260px;
            overflow-y: auto;
            background: rgba(255,255,255,0.95);
            border: 1px solid #aaa;
            font-family: monospace;
            font-size: 12px;
            padding: 6px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label>Src: <input id="src" type="number" value="0" min="0" max="5" /></label>
            <label style="margin-left:8px">Dst: <input id="dst" type="number" value="5" min="0" max="5" /></label>
            <button id="routeBtn" class="btn">Compute Route</button>
            <button id="monitorBtn" class="btn">Monitor this route (threshold: <input id="monitorThreshold" type="number" value="3" min="1" style="width:60px"> min)</button>

        </div>
        <div style="margin-top:8px">
            <strong>Persona</strong><br />
            <input id="personaName" placeholder="Name" style="width:100px" />
            <button id="personaPredictBtn">Predict for Persona</button>
            <div id="dnaPanel" style="margin-top:6px;font-size:13px"></div>
        </div>
        <hr />
        <div>
            <label>Report Node: <input id="rnode" type="number" value="1" min="0" max="5" style="width:70px" /></label>
            <input id="rdesc" placeholder="description" style="width:100%;margin-top:6px" />
            <div style="display:flex;gap:8px;margin-top:6px">
                <select id="rseverity" style="flex:1">
                    <option value="1">Minor</option>
                    <option value="2" selected>Moderate</option>
                    <option value="3">Major</option>
                </select>
                <input id="rduration" type="number" value="120" min="5" max="3600" style="width:100px" />
            </div>
            <div style="display:flex;gap:8px;margin-top:6px">
                <button id="reportBtn" class="btn" style="flex:1">Report Incident</button>
                <button id="simulateBtn" class="btn" style="flex:1">Simulate (async)</button>
            </div>
        </div>
        <hr />
        <div>
            <button id="refreshBtn" class="btn">Refresh Incidents</button>
        </div>
        <div id="status">Status: idle</div>
    </div>

    <div id="map"></div> <!--map is here-->
    <!--//status bar div-->
    <div id="status-bar" style="
  position: fixed; bottom: 0; left: 0; right: 0;
  background: rgba(0,0,0,0.9); color: #fff; padding: 8px 12px;
  font-family: sans-serif; font-size:14px; z-index:1000; display:flex;
  gap:12px; align-items:center; justify-content:space-between;
">
        <!-- Left side -->
        <span id="status-message">Status: Ready</span>

        <!-- Right side -->
        <div>
            ETA:
            <span id="eta-baseline">-</span> ‚Üí
            <span id="eta-current">-</span> (DNA:
            <span id="eta-dna">-</span>)
        </div>
    </div>
        <div>
            <strong id="sb-title">Status:</strong>
            <span id="sb-text">Waiting for route...</span>
        </div>

        <div style="display:flex; gap:12px; align-items:center;">
            <div style="text-align:center;">
                <div style="font-size:11px; opacity:0.8">Baseline ETA</div>
                <div id="eta-baseline" style="font-size:18px; font-weight:700;">‚Äî</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:11px; opacity:0.8">Current ETA</div>
                <div id="eta-current" style="font-size:18px; font-weight:700;">‚Äî</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:11px; opacity:0.8">Recommendation</div>
                <div id="eta-rec" style="font-size:14px; font-weight:700; color:#ffd700;">‚Äî</div>
            </div>
            <div id="eta-saved" style="padding:6px 10px; border-radius:6px; background:rgba(255,255,255,0.12); font-weight:700;"></div>
        </div>
    </div>

    <!--ETA display temp fix-->
    <div id="etaDisplay" style="
  position:absolute; top:10px; right:10px;
  background:white; padding:6px 10px; border-radius:6px;
  box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-family:sans-serif; font-size:14px; z-index:1000;
">
        ETA will appear here
    </div>

    <div id="event-log"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>

        // --- UI Helper ---
        function safeSetText(id, text) {
            const el = document.getElementById(id);
            if (el) {
                el.innerText = text;
            } else {
                console.warn("safeSetText: missing element #" + id);
            }
        }

        /* =========================
           Configuration
           ========================= */
        const API = "http://localhost:8080";

        /* Debounce / UX tuning */
        const ROUTE_DEBOUNCE_MS = 600;     // how long to coalesce route recomputes
        const SSE_RECONNECT_MS = 4000;     // if SSE dies, try reconnect after this ms

        /* Keep state */
        let currentSrc = null, currentDst = null;
        let _lastRouteCompute = 0;
        let _routeComputeTimeout = null;
        let _fitBoundsDone = false;

        /* Map & nodes
           - set map center and node coordinates together so nodes lie on visible roads.
           - change these coordinates to whatever city/area you want.
        */
        const map = L.map('map').setView([50.0642, 19.9895], 14);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '' }).addTo(map);

        // Default 6 node coords (Krak√≥w example). Replace with your desired lat/lon points.
        const nodes = [
            [50.0646, 19.9892],
            [50.0663, 19.9887],
            [50.0674, 19.9886],
            [50.0674, 19.9888],
            [50.0644, 19.9895],
            [50.0656, 19.9968]
        ];

        /* draw static node markers & edges for context */
        const nodeMarkers = [];
        for (let i = 0; i < nodes.length; i++) {
            const m = L.circleMarker(nodes[i], { radius: 7, color: '#222', fillColor: '#fff', fillOpacity: 1 }).addTo(map).bindPopup("Node " + i);
            nodeMarkers.push(m);
        }
        const edges = [[0, 1], [1, 2], [0, 3], [3, 4], [4, 2], [2, 5], [4, 5]];
        edges.forEach(e => {
            const a = nodes[e[0]], b = nodes[e[1]];
            L.polyline([a, b], { color: '#888', weight: 2, opacity: 0.6 }).addTo(map);
        });

        /* =========================
           UI helpers
           ========================= */
        function setStatus(text) {
            // Only update the dedicated span inside the status bar
            safeSetText('status-message', "Status: " + text);
        }


        /* Route drawing: keep references to lines and update in-place for smoothness */
        window.currentPathLines = window.currentPathLines || { baselineLine: null, adjustedLine: null };

        /* =========================
           Incident marker management (incremental)
           ========================= */
        window.incidentMap = window.incidentMap || new Map();
        let _lastIncidentsSerialized = "";

        function createSeverityMarker(latlng, severity) {
            const color = (severity >= 3) ? '#b30000' : (severity === 2 ? '#ff8c00' : '#ffd700');
            return L.circleMarker(latlng, { radius: 9, fillColor: color, color: '#222', weight: 1, fillOpacity: 0.95 });
        }

        const logDiv = document.getElementById("event-log");
        function pushLogLine(text, severity = 1) {
            if (!logDiv) return;
            const p = document.createElement('div');
            p.textContent = text;
            if (severity >= 3) { p.style.color = "darkred"; p.style.fontWeight = "700"; }
            else if (severity === 2) { p.style.color = "darkorange"; }
            else { p.style.color = "#333"; }
            logDiv.insertBefore(p, logDiv.firstChild);
            while (logDiv.childNodes.length > 40) logDiv.removeChild(logDiv.lastChild);
        }

        function formatIncident(inc) {
            let sevLabel = "Unknown";
            let sevIcon = "‚ùì";
            let msg = "";

            switch (inc.severity) {
                case 1:
                    sevLabel = "Minor";
                    sevIcon = "‚ö†Ô∏è";
                    msg = `Minor delay at Stop ${inc.node_or_edge} (expect ~2 min longer)`;
                    break;
                case 2:
                    sevLabel = "Moderate";
                    sevIcon = "üöß";
                    msg = `Moderate disruption at Stop ${inc.node_or_edge} (expect ~5‚Äì10 min longer)`;
                    break;
                case 3:
                    sevLabel = "Major";
                    sevIcon = "üö®";
                    msg = `Major disruption at Stop ${inc.node_or_edge} ‚Äî severe delays likely`;
                    break;
                default:
                    msg = `Incident at Stop ${inc.node_or_edge}`;
            }

            return {
                label: sevLabel,
                icon: sevIcon,
                message: msg,
                raw: inc
            };
        }

        function renderIncidentsIncremental(list) {
            const incoming = new Map();
            (list || []).forEach(i => incoming.set(String(i.id), i));

            // remove cleared
            for (const [id, entry] of window.incidentMap.entries()) {
                if (!incoming.has(id)) {
                    try { map.removeLayer(entry.marker); } catch (e) { }
                    window.incidentMap.delete(id);
                    pushLogLine(`[${new Date().toLocaleTimeString()}] Cleared id=${id}`, 1);
                }
            }

            // add/update incoming
            incoming.forEach((inc, id) => {
                const prev = window.incidentMap.get(id);
                const severity = inc.severity || 1;
                const latlng = nodes[inc.node_or_edge];
                if (!latlng) return; // invalid node

                const fmt = formatIncident(inc); // friendly text

                if (!prev) {
                    const m = createSeverityMarker(latlng, severity).addTo(map);
                    m.bindPopup(`<div style="font-size:13px"><strong>${fmt.message}</strong><br/><em>${inc.description || ''}</em><br/>id: ${inc.id}</div>`);
                    window.incidentMap.set(id, { marker: m, inc: JSON.stringify(inc) });
                    pushLogLine(`[${new Date().toLocaleTimeString()}] New: ${fmt.message} (id:${id})`, severity);
                } else {
                    const serialized = JSON.stringify(inc);
                    if (serialized !== prev.inc) {
                        // update style/popup
                        try {
                            prev.marker.setStyle && prev.marker.setStyle({ fillColor: (severity >= 3) ? '#b30000' : (severity === 2 ? '#ff8c00' : '#ffd700') });
                            prev.marker.setPopupContent && prev.marker.setPopupContent(`<div style="font-size:13px"><strong>${fmt.message}</strong><br/><em>${inc.description || ''}</em><br/>id: ${inc.id}</div>`);
                        } catch (e) { /* ignore popup update errors */ }
                        prev.inc = serialized;
                        pushLogLine(`[${new Date().toLocaleTimeString()}] Updated: ${fmt.message} (id:${id})`, severity);
                    }
                }
            });

            setStatus("Incidents: " + (list ? list.length : 0));
        }


        /* =========================
           Fetch incidents (fallback)
           ========================= */
        async function fetchIncidents() {
            try {
                const res = await fetch(API + '/incidents');
                const arr = await res.json();
                renderIncidentsIncremental(arr);
            } catch (e) {
                setStatus("incidents fetch failed: " + e.message);
            }
        }

        /* =========================
           Route computation (debounced, smooth draw)
           ========================= */
        async function computeRoute(src, dst) {
            const now = Date.now();
            if (now - _lastRouteCompute < ROUTE_DEBOUNCE_MS) {
                if (_routeComputeTimeout) clearTimeout(_routeComputeTimeout);
                _routeComputeTimeout = setTimeout(() => { _routeComputeTimeout = null; computeRoute(src, dst); }, ROUTE_DEBOUNCE_MS);
                return;
            }
            _lastRouteCompute = now;
            currentSrc = src; currentDst = dst;
            setStatus("computing route...");

            try {
                const r = await fetch(API + '/route', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ src, dst }) });
                const j = await r.json();
                console.log("route response", j);

                // prepare pts
                let baselinePts = null, adjustedPts = null;
                if (j.baseline && Array.isArray(j.baseline.path) && j.baseline.path.length) baselinePts = j.baseline.path.map(i => nodes[i]);
                if (j.adjusted && Array.isArray(j.adjusted.path) && j.adjusted.path.length) adjustedPts = j.adjusted.path.map(i => nodes[i]);

                // baseline (dashed blue)
                if (baselinePts) {
                    if (window.currentPathLines.baselineLine) {
                        window.currentPathLines.baselineLine.setLatLngs(baselinePts);
                    } else {
                        window.currentPathLines.baselineLine = L.polyline(baselinePts, { dashArray: '6,6', weight: 3, color: '#0077cc' }).addTo(map);
                    }
                } else {
                    if (window.currentPathLines.baselineLine) { map.removeLayer(window.currentPathLines.baselineLine); window.currentPathLines.baselineLine = null; }
                }

                // adjusted (solid red)
                if (adjustedPts) {
                    if (window.currentPathLines.adjustedLine) {
                        window.currentPathLines.adjustedLine.setLatLngs(adjustedPts);
                    } else {
                        window.currentPathLines.adjustedLine = L.polyline(adjustedPts, { color: 'red', weight: 4 }).addTo(map);
                    }
                } else {
                    if (window.currentPathLines.adjustedLine) { map.removeLayer(window.currentPathLines.adjustedLine); window.currentPathLines.adjustedLine = null; }
                }

                // compute ETAs and saved text
                const baseEta = (j.baseline && typeof j.baseline.eta_minutes === 'number') ? j.baseline.eta_minutes : null;
                const adjEta = (j.adjusted && typeof j.adjusted.eta_minutes === 'number') ? j.adjusted.eta_minutes : null;
                let recText = '';
                if (j.recommendation === 'baseline_faster') recText = 'Baseline route is faster';
                else if (j.recommendation === 'adjusted_faster') recText = 'Alternative is faster';
                else if (j.recommendation === 'equal') recText = 'Both equal';
                else if (j.recommendation === 'no_path') recText = 'No path available';

                let savedText = '';
                if (baseEta !== null && adjEta !== null) {
                    const diff = baseEta - adjEta;
                    if (diff > 0) savedText = ` ‚úÖ Baseline faster by ${Math.abs(diff)} min`;
                    else if (diff < 0) savedText = ` üöÄ Adjusted faster by ${Math.abs(diff)} min`;
                    else savedText = ` ‚öñ Equal time`;
                } else if (baseEta !== null && adjEta === null) savedText = ` ‚ö† Only baseline available`;
                else if (adjEta !== null && baseEta === null) savedText = ` ‚ö† Only adjusted available`;

                // --- SAFE ETA DOM UPDATES ---
                try {
                    const baseText = baseEta !== null ? `${baseEta} min` : 'n/a';
                    const adjText = adjEta !== null ? `${adjEta} min` : 'n/a';
                    const recTextSafe = recText || '‚Äî';
                    const savedTextSafe = savedText || '';

                    // status bar fields
                    safeSetText('eta-baseline', baseText);
                    safeSetText('eta-current', adjText);
                    safeSetText('eta-rec', recTextSafe);
                    safeSetText('eta-saved', savedTextSafe);

                    // --- update DNA ETA display (if present) ---
                    try {
                        const dnaVal = (j && typeof j.dna_predicted_extra_minutes === 'number') ? Math.round(j.dna_predicted_extra_minutes) : null;
                        if (dnaVal !== null) {
                            safeSetText('eta-dna', dnaVal + 'm');
                        } else {
                            // fallback: if server supplied string message only
                            if (j && j.dna_message) safeSetText('eta-dna', j.dna_message);
                            else safeSetText('eta-dna', '‚Äî');
                        }
                    } catch (e) {
                        console.warn('dna display update failed', e);
                        safeSetText('eta-dna', '‚Äî');
                    }

                    // status line
                    setStatus(`ETA (baseline): ${baseText} | ETA (current): ${adjText}`);

                    // top-right persistent ETA display
                    const etaDisplay = document.getElementById('etaDisplay');
                    if (etaDisplay) {
                        etaDisplay.innerText =
                            `Baseline: ${baseText} | Adjusted: ${adjText} | ${recTextSafe} ${savedTextSafe}`;
                    }
                } catch (domErr) {
                    console.error("ETA DOM update failed:", domErr);
                }

                // fit bounds only once to avoid jumping
                try {
                    if (!_fitBoundsDone) {
                        const allPts = [];
                        if (baselinePts) allPts.push(...baselinePts);
                        if (adjustedPts) allPts.push(...adjustedPts);
                        if (allPts.length) {
                            const bounds = L.latLngBounds(allPts);
                            map.fitBounds(bounds.pad(0.2), { animate: true });
                            _fitBoundsDone = true;
                        }
                    }
                } catch (e) { /* ignore */ }

            } catch (e) {
                setStatus("route error: " + e.message);
            }
        }

        /* =========================
           UI bindings
           ========================= */
        document.getElementById('routeBtn').addEventListener('click', () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            computeRoute(src, dst);
        });

        document.getElementById('simulateBtn').addEventListener('click', async () => {
            const node = Number(document.getElementById('rnode').value);
            const desc = document.getElementById('rdesc').value || "simulated";
            const severity = Number(document.getElementById('rseverity').value || 2);
            const duration_s = Number(document.getElementById('rduration').value || 120);
            try {
                const r = await fetch(API + '/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node, desc, delay_ms: 200, severity, duration_s })
                });
                const j = await r.json();
                console.log("simulate response", j);
                setStatus("simulate scheduled (server accepted)");
            } catch (e) { setStatus("simulate failed: " + e.message); console.error(e); }
        });
        document.getElementById('reportBtn').addEventListener('click', async () => {
            const node = Number(document.getElementById('rnode').value);
            const desc = document.getElementById('rdesc').value || "reported";
            const severity = Number(document.getElementById('rseverity').value || 2);
            const duration_s = Number(document.getElementById('rduration').value || 120);
            try {
                const r = await fetch(API + '/report', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node, desc, severity, duration_s })
                });
                const j = await r.json();
                console.log("report response", j);
                setStatus("report submitted");
            } catch (e) { setStatus("report failed: " + e.message); console.error(e); }
        });

        document.getElementById('refreshBtn').addEventListener('click', fetchIncidents);

        // Safe persona predict handler (replace your existing handler with this)
        document.getElementById('personaPredictBtn').addEventListener('click', async () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            const personaName = (document.getElementById('personaName') && document.getElementById('personaName').value) || 'Persona';
            const persona = { name: personaName };

            try {
                const resp = await fetch(API + '/predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ src, dst, persona })
                });

                if (!resp.ok) {
                    const text = await resp.text().catch(() => '');
                    pushLogLine(`predict failed: HTTP ${resp.status} ${text}`, 2);
                    return;
                }

                const j = await resp.json();
                // defensive extracts
                const predicted = (typeof j.dna_predicted_extra_minutes === 'number') ? j.dna_predicted_extra_minutes : Number(j.dna_predicted_extra_minutes) || 0;

                pushLogLine(`Persona "${personaName}" predicted extra: ${predicted} min`, 1);

                // Update dnaPanel safely
                const panel = document.getElementById('dnaPanel');
                if (panel) {
                    // create small block for this persona
                    const el = document.createElement('div');
                    el.style.marginTop = '6px';
                    el.textContent = `${personaName}: +${predicted} min ‚Äî ${j.dna_message || ''}`;
                    panel.appendChild(el);
                } else {
                    console.warn('dnaPanel not found in DOM.');
                }

                // Update ETA display only if the element exists (guarded)
                const etaCurEl = document.getElementById('eta-current');
                if (etaCurEl) {
                    // we purposely don't overwrite the current ETA with predicted ‚Äî instead show appended note
                    const note = ` (+${predicted}m predicted)`;
                    // avoid blowing up if innerText is missing
                    const baseText = etaCurEl.innerText || etaCurEl.textContent || '';
                    etaCurEl.innerText = baseText + note;
                } else {
                    console.warn('eta-current element missing; skipping ETA update.');
                }

            } catch (err) {
                // more informative error log
                pushLogLine('predict error: ' + (err && err.message ? err.message : String(err)), 2);
                console.error('predict handler error (full):', err);
            }
        });


        // monitor button handler
        document.getElementById('monitorBtn').addEventListener('click', async () => {
            const src = Number(document.getElementById('src').value);
            const dst = Number(document.getElementById('dst').value);
            const threshold = Number(document.getElementById('monitorThreshold').value || 3);
            try {
                const r = await fetch(API + '/monitor', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ src, dst, threshold })
                });
                const j = await r.json();
                if (j.monitor_id) {
                    pushLogLine(`Monitoring route ${src}->${dst} (id:${j.monitor_id}) threshold:${threshold}min`, 1);
                } else {
                    pushLogLine(`Monitor failed: ${JSON.stringify(j)}`, 1);
                }
            } catch (e) {
                pushLogLine(`Monitor POST error: ${e.message}`, 1);
            }
        });

        // inside your SSE onmessage handler (where you parse data), add:
        if (data.monitor_alerts && data.monitor_alerts.length) {
            data.monitor_alerts.forEach(a => {
                // friendly text
                const text = `[ALERT] route ${a.src}->${a.dst} delayed by ${a.delta} min (eta ${a.eta_adj} vs baseline ${a.eta_base})`;
                pushLogLine(text, 3);
                // visual: flash status or show toast
                setStatus("ALERT: " + text);
                // optionally show a big callout on map or highlight lines:
                if (window.currentPathLines && window.currentPathLines.adjustedLine) {
                    // briefly pulse the adjusted line
                    window.currentPathLines.adjustedLine.setStyle({ color: '#ff0000', weight: 6 });
                    setTimeout(() => {
                        if (window.currentPathLines.adjustedLine) window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 });
                    }, 4000);
                }
            });
        }

        /* =========================
           SSE subscribe (reconnect on error)
           ========================= */
        function subscribeEvents() {
            let evt = null;

            function connect() {
                evt = new EventSource(API + "/events");
                evt.onopen = () => { console.log("SSE connected"); pushLogLine(`[${new Date().toLocaleTimeString()}] SSE connected`, 1); };
                evt.onmessage = function (ev) {
                    try {
                        const data = JSON.parse(ev.data);

                        // === Existing incident handling ===
                        const list = data.incidents || [];
                        const serialized = JSON.stringify(list.map(i => ({
                            id: i.id,
                            node: i.node_or_edge,
                            sev: i.severity,
                            expires: i.expires_at
                        })));
                        if (serialized !== _lastIncidentsSerialized) {
                            _lastIncidentsSerialized = serialized;
                            renderIncidentsIncremental(list);
                        }

                        // === NEW: DNA summary panel ===
                        if (data.dna_summary) {
                            try {
                                const dna = data.dna_summary;
                                const stats = dna.node_stats || {};
                                let html = '<strong>TransitDNA</strong><br/>';
                                const keys = Object.keys(stats)
                                    .sort((a, b) => (stats[b].avg_delay || 0) - (stats[a].avg_delay || 0))
                                    .slice(0, 3);
                                keys.forEach(k => {
                                    const s = stats[k];
                                    html += `Node ${k}: ${Math.round((s.avg_delay || 0))}m (n=${s.count || 0})<br/>`;
                                });
                                const el = document.getElementById('dnaPanel');
                                if (el) el.innerHTML = html;
                            } catch (e) { console.error('dna render err', e); }
                        }

                        // === NEW: Monitor alerts ===
                        if (data.monitor_alerts && data.monitor_alerts.length) {
                            data.monitor_alerts.forEach(a => {
                                const text = `[ALERT] route ${a.src}->${a.dst} delayed by ${a.delta} min (eta ${a.eta_adj} vs baseline ${a.eta_base})`;
                                pushLogLine(text, 3);
                                setStatus("ALERT: " + text);
                                if (window.currentPathLines && window.currentPathLines.adjustedLine) {
                                    window.currentPathLines.adjustedLine.setStyle({ color: '#ff0000', weight: 6 });
                                    setTimeout(() => {
                                        if (window.currentPathLines.adjustedLine)
                                            window.currentPathLines.adjustedLine.setStyle({ color: 'red', weight: 4 });
                                    }, 4000);
                                }
                            });
                        }

                    } catch (err) {
                        console.error("SSE parse error", err, ev.data);
                    }
                };

                evt.onerror = (err) => {
                    console.error("SSE error", err);
                    pushLogLine(`[${new Date().toLocaleTimeString()}] SSE connection error ‚Äî reconnecting...`, 1);
                    try { evt.close(); } catch (e) { }
                    setTimeout(connect, SSE_RECONNECT_MS);
                };
            }

            connect();
        }

        subscribeEvents();

        /* initial fallback */
        fetchIncidents();
        setInterval(fetchIncidents, 30000); // very infrequent fallback polling
    </script>
</body>
</html>
